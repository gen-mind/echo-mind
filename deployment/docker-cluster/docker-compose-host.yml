# docker-compose-host.yml
# Production deployment - all URLs configured via .env
# Only Traefik exposes public ports (80, 443)
# All other services are internal-only, routed via Traefik

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH}/postgres

  qdrant_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH}/qdrant

  minio_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH}/minio

  nats_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH}/nats

  portainer_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH}/portainer

  tensorboard_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH}/tensorboard

services:
  # ===============================================
  # Traefik - Reverse Proxy (ONLY PUBLIC PORTS)
  # ===============================================
  traefik:
    image: traefik:v3.3
    container_name: infra-traefik
    hostname: traefik
    ports:
      - "80:80"
      - "443:443"
      - "127.0.0.1:8080:8080"  # Dashboard - localhost only (use SSH tunnel)
    networks:
      - frontend
      - backend
    volumes:
      - ${DATA_PATH}/traefik/certificates:/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ${CONFIG_PATH}/traefik/dynamic.yml:/etc/traefik/dynamic/dynamic.yml:ro
    healthcheck:
      test: ["CMD", "traefik", "healthcheck", "--ping"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 10s
    restart: unless-stopped
    command:
      - "--api.dashboard=true"
      - "--api.insecure=true"
      - "--ping=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.file.directory=/etc/traefik/dynamic"
      - "--providers.file.watch=true"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--log.level=INFO"
      - "--metrics.prometheus=true"
      - "--metrics.prometheus.entrypoint=traefik"
      # SSL - Let's Encrypt ACME
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      # HTTP to HTTPS redirect
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
    labels:
      - "traefik.enable=true"

  # ===============================================
  # PostgreSQL - Shared DB (Authentik + API)
  # ===============================================
  postgres:
    image: postgres:16.4
    container_name: data-postgres
    hostname: postgres
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - TZ=${TZ:-UTC}
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U ${POSTGRES_USER}']
      start_period: 30s
      interval: 10s
      timeout: 10s
      retries: 5
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ${CONFIG_PATH}/postgres/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    restart: unless-stopped
    networks:
      - backend
    # Expose to localhost for PyCharm database connection (via SSH tunnel)
    ports:
      - "127.0.0.1:5432:5432"
    labels:
      - "traefik.enable=false"

  # ===============================================
  # Adminer - PostgreSQL Web UI (Protected by Authentik)
  # ===============================================
  adminer:
    image: adminer:4.8.1-standalone
    container_name: infra-adminer
    hostname: adminer
    environment:
      - ADMINER_DEFAULT_SERVER=postgres
      - ADMINER_DESIGN=pepa-linha-dark
      - ADMINER_PLUGINS=tables-filter tinymce
    restart: unless-stopped
    networks:
      - backend
      - frontend
    depends_on:
      postgres:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.adminer.rule=Host(`${POSTGRES_DOMAIN}`)"
      - "traefik.http.routers.adminer.entrypoints=websecure"
      - "traefik.http.routers.adminer.tls.certresolver=letsencrypt"
      - "traefik.http.routers.adminer.middlewares=authentik-forward-auth@file"
      - "traefik.http.services.adminer.loadbalancer.server.port=8080"

  # ===============================================
  # Authentik Server - OIDC Provider
  # ===============================================
  authentik-server:
    image: ghcr.io/goauthentik/server:2025.10.3
    container_name: infra-authentik-server
    hostname: authentik-server
    command: server
    environment:
      - AUTHENTIK_LOG_LEVEL=error
      - AUTHENTIK_POSTGRESQL__HOST=postgres
      - AUTHENTIK_POSTGRESQL__USER=${POSTGRES_USER}
      - AUTHENTIK_POSTGRESQL__NAME=${AUTHENTIK_DB_NAME}
      - AUTHENTIK_POSTGRESQL__PASSWORD=${POSTGRES_PASSWORD}
      - AUTHENTIK_SECRET_KEY=${AUTHENTIK_SECRET_KEY}
    volumes:
      - ${DATA_PATH}/authentik/media:/media
      - ${DATA_PATH}/authentik/custom-templates:/templates
    depends_on:
      - postgres
    restart: unless-stopped
    networks:
      - frontend
      - backend
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.authentik.rule=Host(`${AUTHENTIK_DOMAIN}`)"
      - "traefik.http.routers.authentik.entrypoints=websecure"
      - "traefik.http.routers.authentik.tls.certresolver=letsencrypt"
      - "traefik.http.routers.authentik.middlewares=authentik-cors"
      - "traefik.http.services.authentik.loadbalancer.server.port=9000"
      # CORS middleware for OIDC endpoints (required for SPA clients)
      - "traefik.http.middlewares.authentik-cors.headers.accesscontrolallowmethods=GET,OPTIONS,POST"
      - "traefik.http.middlewares.authentik-cors.headers.accesscontrolallowheaders=*"
      - "traefik.http.middlewares.authentik-cors.headers.accesscontrolalloworiginlist=${CORS_ORIGINS}"
      - "traefik.http.middlewares.authentik-cors.headers.accesscontrolallowcredentials=true"
      - "traefik.http.middlewares.authentik-cors.headers.accesscontrolmaxage=100"
      - "traefik.http.middlewares.authentik-cors.headers.addvaryheader=true"

  # ===============================================
  # Authentik Worker - Background Tasks
  # ===============================================
  authentik-worker:
    image: ghcr.io/goauthentik/server:2025.10.3
    container_name: infra-authentik-worker
    hostname: authentik-worker
    command: worker
    environment:
      - AUTHENTIK_LOG_LEVEL=error
      - AUTHENTIK_POSTGRESQL__HOST=postgres
      - AUTHENTIK_POSTGRESQL__USER=${POSTGRES_USER}
      - AUTHENTIK_POSTGRESQL__NAME=${AUTHENTIK_DB_NAME}
      - AUTHENTIK_POSTGRESQL__PASSWORD=${POSTGRES_PASSWORD}
      - AUTHENTIK_SECRET_KEY=${AUTHENTIK_SECRET_KEY}
      - AUTHENTIK_BOOTSTRAP_PASSWORD=${AUTHENTIK_BOOTSTRAP_PASSWORD}
      - AUTHENTIK_BOOTSTRAP_EMAIL=${AUTHENTIK_BOOTSTRAP_EMAIL}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ${DATA_PATH}/authentik/media:/media
      - ${DATA_PATH}/authentik/custom-templates:/templates
      - ${DATA_PATH}/authentik/certs:/certs
    depends_on:
      - postgres
    restart: unless-stopped
    networks:
      - backend

  # ===============================================
  # Qdrant - Vector Database (NO PUBLIC PORTS)
  # ===============================================
  qdrant:
    image: qdrant/qdrant:latest
    container_name: data-qdrant
    hostname: qdrant
    # NO ports - internal only, exposed via Traefik
    volumes:
      - qdrant_data:/qdrant/storage
      - ${CONFIG_PATH}/qdrant/production.yaml:/qdrant/config/production.yaml
    healthcheck:
      test: ["CMD-SHELL", "timeout 2 bash -c '</dev/tcp/localhost/6333' || exit 1"]
      start_period: 30s
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.qdrant.rule=Host(`${QDRANT_DOMAIN}`)"
      - "traefik.http.routers.qdrant.entrypoints=websecure"
      - "traefik.http.routers.qdrant.tls.certresolver=letsencrypt"
      - "traefik.http.routers.qdrant.middlewares=authentik-forward-auth@file"
      - "traefik.http.services.qdrant.loadbalancer.server.port=6333"

  # ===============================================
  # MinIO - Object Storage (NO PUBLIC PORTS)
  # ===============================================
  minio:
    image: minio/minio:latest
    container_name: data-minio
    hostname: minio
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=${MINIO_ROOT_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}
      - MINIO_PROMETHEUS_AUTH_TYPE=public
    # NO ports - internal only, console exposed via Traefik
    volumes:
      - minio_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    restart: unless-stopped
    networks:
      - frontend
      - backend
    labels:
      - "traefik.enable=true"
      # MinIO Console (protected by Authentik Forward Auth)
      - "traefik.http.routers.minio-console.rule=Host(`${MINIO_DOMAIN}`)"
      - "traefik.http.routers.minio-console.entrypoints=websecure"
      - "traefik.http.routers.minio-console.tls.certresolver=letsencrypt"
      - "traefik.http.routers.minio-console.middlewares=authentik-forward-auth@file"
      - "traefik.http.routers.minio-console.service=minio-console"
      - "traefik.http.services.minio-console.loadbalancer.server.port=9001"
      # MinIO API (for S3-compatible access)
      - "traefik.http.routers.minio-api.rule=Host(`${S3_DOMAIN}`)"
      - "traefik.http.routers.minio-api.entrypoints=websecure"
      - "traefik.http.routers.minio-api.tls.certresolver=letsencrypt"
      - "traefik.http.routers.minio-api.service=minio-api"
      - "traefik.http.services.minio-api.loadbalancer.server.port=9000"

  # ===============================================
  # NATS - Message Bus (NO PUBLIC PORTS)
  # ===============================================
  nats:
    image: nats:alpine
    container_name: infra-nats
    hostname: nats
    # NO ports - internal only
    volumes:
      - nats_data:/data/nats
      - ${CONFIG_PATH}/nats/nats-server.conf:/nats-server.conf
    command:
      - "--config=/nats-server.conf"
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O /dev/null http://localhost:8222/healthz || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # Nui - NATS Management UI (Protected by Authentik)
  # ===============================================
  nui:
    image: ghcr.io/nats-nui/nui:latest
    container_name: echomind-nui
    hostname: nui
    environment:
      # NATS connection defaults
      - NUI_NATS_URL=nats://nats:4222
      - NUI_NATS_NAME=EchoMind NATS
      # Server configuration
      - NUI_SERVER_PORT=31311
      - NUI_SERVER_HOST=0.0.0.0
      # Authentication disabled (handled by Traefik ForwardAuth)
      - NUI_SERVER_AUTH_ENABLED=false
    restart: unless-stopped
    networks:
      - backend
      - frontend
    depends_on:
      nats:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.nui.rule=Host(`${NATS_DOMAIN}`)"
      - "traefik.http.routers.nui.entrypoints=websecure"
      - "traefik.http.routers.nui.tls.certresolver=letsencrypt"
      - "traefik.http.routers.nui.middlewares=authentik-forward-auth@file"
      - "traefik.http.services.nui.loadbalancer.server.port=31311"

  # ===============================================
  # Redis - Shared Cache & Queue
  # ===============================================
  redis:
    image: redis:7-alpine
    container_name: data-redis
    hostname: redis
    command: >
      redis-server
      --maxmemory 512mb
      --maxmemory-policy noeviction
      --save ""
      --appendonly no
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # EchoMind API - FastAPI Application
  # ===============================================
  api:
    image: gsantopaolo/echomind-api:${API_VERSION:-0.1.0-beta.1}
    build:
      context: ../../src
      dockerfile: api/Dockerfile
    container_name: echomind-api
    hostname: api
    env_file:
      - ${CONFIG_PATH}/api/api.env
    environment:
      - API_DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${API_DB_NAME}
      - API_QDRANT_HOST=qdrant
      - API_QDRANT_PORT=6333
      - API_MINIO_ENDPOINT=minio:9000
      - API_MINIO_ACCESS_KEY=${MINIO_ROOT_USER}
      - API_MINIO_SECRET_KEY=${MINIO_ROOT_PASSWORD}
      - API_MINIO_PUBLIC_ENDPOINT=https://${S3_DOMAIN}
      - API_NATS_URL=nats://nats:4222
      # Auth - issuer must match JWT's 'iss' claim exactly (external URL)
      - API_AUTH_ISSUER=${API_AUTH_ISSUER}
      - API_AUTH_AUDIENCE=${API_AUTH_AUDIENCE}
      - API_AUTH_JWKS_URL=${API_AUTH_JWKS_URL}
      # OAuth/OIDC for WebUI SSO login (reuses existing WEB_OIDC_* vars)
      # Authentik uses global OAuth2 endpoints (not per-application)
      - API_OAUTH_CLIENT_ID=${WEB_OIDC_CLIENT_ID}
      - API_OAUTH_CLIENT_SECRET=${WEB_OIDC_CLIENT_SECRET}
      - API_OAUTH_PROVIDER_NAME=Authentik
      - API_OAUTH_AUTHORIZE_URL=${AUTHENTIK_URL}/application/o/authorize/
      - API_OAUTH_TOKEN_URL=${AUTHENTIK_URL}/application/o/token/
      - API_OAUTH_USERINFO_URL=${AUTHENTIK_URL}/application/o/userinfo/
      - API_OAUTH_REDIRECT_URI=https://${DOMAIN}/oauth/oidc/callback
      - API_OAUTH_SCOPE=${WEB_OIDC_SCOPE:-openid profile email}
      - API_OAUTH_FRONTEND_URL=https://${DOMAIN}
      - API_OAUTH_COOKIE_DOMAIN=.${DOMAIN}
      # Langfuse (optional - empty = disabled)
      - LANGFUSE_PUBLIC_KEY=${LANGFUSE_PUBLIC_KEY:-}
      - LANGFUSE_SECRET_KEY=${LANGFUSE_SECRET_KEY:-}
      - LANGFUSE_BASE_URL=http://langfuse-web:3000
      - API_RAGAS_SAMPLE_RATE=${RAGAS_SAMPLE_RATE:-0.1}
    depends_on:
      postgres:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      migration:
        condition: service_completed_successfully
      minio:
        condition: service_healthy
      nats:
        condition: service_started
      authentik-server:
        condition: service_started
    restart: unless-stopped
    networks:
      - frontend
      - backend
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.api.rule=Host(`${API_DOMAIN}`)"
      - "traefik.http.routers.api.entrypoints=websecure"
      - "traefik.http.routers.api.tls.certresolver=letsencrypt"
      - "traefik.http.routers.api.middlewares=api-cors"
      - "traefik.http.services.api.loadbalancer.server.port=8000"
      # CORS middleware for API (required for SPA)
      - "traefik.http.middlewares.api-cors.headers.accesscontrolallowmethods=GET,OPTIONS,PUT,POST,DELETE,PATCH"
      - "traefik.http.middlewares.api-cors.headers.accesscontrolallowheaders=*"
      - "traefik.http.middlewares.api-cors.headers.accesscontrolalloworiginlist=${CORS_ORIGINS}"
      - "traefik.http.middlewares.api-cors.headers.accesscontrolallowcredentials=true"
      - "traefik.http.middlewares.api-cors.headers.accesscontrolmaxage=100"
      - "traefik.http.middlewares.api-cors.headers.addvaryheader=true"
      # =============================================
      # Path-based routing for WebUI domain
      # Routes /api/* and /oauth/* from main domain to API backend
      # This allows the SvelteKit frontend to call /api/* and /oauth/*
      # on same origin, with Traefik forwarding to EchoMind API
      # Includes both /api/v1/* (EchoMind endpoints) and
      # /api/* (Open WebUI compatibility endpoints)
      # =============================================
      - "traefik.http.routers.api-webui.rule=Host(`${DOMAIN}`) && (PathPrefix(`/api`) || PathPrefix(`/oauth`) || PathPrefix(`/ws`))"
      - "traefik.http.routers.api-webui.entrypoints=websecure"
      - "traefik.http.routers.api-webui.tls.certresolver=letsencrypt"
      - "traefik.http.routers.api-webui.middlewares=api-cors"
      - "traefik.http.routers.api-webui.service=api"
      - "traefik.http.routers.api-webui.priority=100"

  # ===============================================
  # EchoMind Migration - Database Migrations
  # ===============================================
  migration:
    image: gsantopaolo/echomind-migration:${MIGRATION_VERSION:-0.1.0-beta.1}
    build:
      context: ../../src
      dockerfile: migration/Dockerfile
    container_name: init-migration
    hostname: migration
    env_file:
      - ${CONFIG_PATH}/migration/migration.env
    environment:
      - MIGRATION_DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${API_DB_NAME}
      - ENABLE_LANGFUSE=${ENABLE_LANGFUSE:-false}
    depends_on:
      postgres:
        condition: service_healthy
    restart: "no"
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # EchoMind Embedder - Text to Vector Embeddings
  # ===============================================
  embedder:
    image: gsantopaolo/echomind-embedder:${EMBEDDER_VERSION:-0.1.0-beta.1}
    build:
      context: ../../src
      dockerfile: embedder/Dockerfile
      args:
        - HF_TOKEN=${HF_TOKEN:-}
    container_name: echomind-embedder
    hostname: embedder
    # NO ports - internal only (gRPC accessed by other services)
    env_file:
      - ${CONFIG_PATH}/embedder/embedder.env
    environment:
      - EMBEDDER_QDRANT_HOST=qdrant
      - EMBEDDER_QDRANT_PORT=6333
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 10s
      start_period: 300s
      retries: 5
    depends_on:
      qdrant:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # EchoMind Orchestrator - Connector Sync Scheduler
  # ===============================================
  orchestrator:
    image: gsantopaolo/echomind-orchestrator:${ORCHESTRATOR_VERSION:-0.1.0-beta.1}
    build:
      context: ../../src
      dockerfile: orchestrator/Dockerfile
    container_name: echomind-orchestrator
    hostname: orchestrator
    env_file:
      - ${CONFIG_PATH}/orchestrator/orchestrator.env
    environment:
      - ORCHESTRATOR_DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${API_DB_NAME}
      - ORCHESTRATOR_NATS_URL=nats://nats:4222
    depends_on:
      postgres:
        condition: service_healthy
      migration:
        condition: service_completed_successfully
      nats:
        condition: service_started
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # EchoMind Connector - External Data Source Fetcher
  # ===============================================
  connector:
    image: gsantopaolo/echomind-connector:${CONNECTOR_VERSION:-0.1.0-beta.1}
    build:
      context: ../../src
      dockerfile: connector/Dockerfile
    container_name: echomind-connector
    hostname: connector
    env_file:
      - ${CONFIG_PATH}/connector/connector.env
    environment:
      - CONNECTOR_DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${API_DB_NAME}
      - CONNECTOR_NATS_URL=nats://nats:4222
      - CONNECTOR_MINIO_ENDPOINT=minio:9000
      - CONNECTOR_MINIO_ACCESS_KEY=${MINIO_ROOT_USER}
      - CONNECTOR_MINIO_SECRET_KEY=${MINIO_ROOT_PASSWORD}
      # Langfuse (optional - empty = disabled)
      - LANGFUSE_PUBLIC_KEY=${LANGFUSE_PUBLIC_KEY:-}
      - LANGFUSE_SECRET_KEY=${LANGFUSE_SECRET_KEY:-}
      - LANGFUSE_BASE_URL=http://langfuse-web:3000
    depends_on:
      postgres:
        condition: service_healthy
      migration:
        condition: service_completed_successfully
      minio:
        condition: service_healthy
      nats:
        condition: service_started
      orchestrator:
        condition: service_started
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # EchoMind Ingestor - Document Processing Pipeline
  # ===============================================
  ingestor:
    image: gsantopaolo/echomind-ingestor:${INGESTOR_VERSION:-0.1.0-beta.1}
    build:
      context: ../../src
      dockerfile: ingestor/Dockerfile
      args:
        - HF_TOKEN=${HF_TOKEN:-}
    container_name: echomind-ingestor
    hostname: ingestor
    env_file:
      - ${CONFIG_PATH}/ingestor/ingestor.env
    environment:
      - INGESTOR_DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${API_DB_NAME}
      - INGESTOR_NATS_URL=nats://nats:4222
      - INGESTOR_MINIO_ENDPOINT=minio:9000
      - INGESTOR_MINIO_ACCESS_KEY=${MINIO_ROOT_USER}
      - INGESTOR_MINIO_SECRET_KEY=${MINIO_ROOT_PASSWORD}
      - INGESTOR_QDRANT_HOST=qdrant
      - INGESTOR_QDRANT_PORT=6333
      - INGESTOR_EMBEDDER_HOST=embedder
      - INGESTOR_EMBEDDER_PORT=50051
      # Langfuse (optional - empty = disabled)
      - LANGFUSE_PUBLIC_KEY=${LANGFUSE_PUBLIC_KEY:-}
      - LANGFUSE_SECRET_KEY=${LANGFUSE_SECRET_KEY:-}
      - LANGFUSE_BASE_URL=http://langfuse-web:3000
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 10s
      start_period: 180s
      retries: 5
    depends_on:
      postgres:
        condition: service_healthy
      migration:
        condition: service_completed_successfully
      minio:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      nats:
        condition: service_healthy
      embedder:
        condition: service_healthy
      connector:
        condition: service_started
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # EchoMind Guardian - DLQ Monitoring & Alerting
  # ===============================================
  guardian:
    image: gsantopaolo/echomind-guardian:${GUARDIAN_VERSION:-0.1.0-beta.1}
    build:
      context: ../../src
      dockerfile: guardian/Dockerfile
    container_name: echomind-guardian
    hostname: guardian
    env_file:
      - ${CONFIG_PATH}/guardian/guardian.env
    environment:
      - GUARDIAN_NATS_URL=nats://nats:4222
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 3
    depends_on:
      nats:
        condition: service_healthy
      orchestrator:
        condition: service_started
    restart: unless-stopped
    networks:
      - backend
    labels:
      - "traefik.enable=false"

  # ===============================================
  # Portainer - Docker Management UI
  # ===============================================
  portainer:
    image: portainer/portainer-ce:alpine
    container_name: infra-portainer
    hostname: portainer
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=3", "--spider", "http://127.0.0.1:9000/api/system/status"]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 3
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    networks:
      - frontend
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.portainer.rule=Host(`${PORTAINER_DOMAIN}`)"
      - "traefik.http.routers.portainer.entrypoints=websecure"
      - "traefik.http.routers.portainer.tls.certresolver=letsencrypt"
      - "traefik.http.services.portainer.loadbalancer.server.port=9000"

  # ===============================================
  # TensorBoard - Official TensorFlow Container
  # ===============================================
  tensorboard:
    image: tensorflow/tensorflow:2.18.0
    container_name: observability-tensorboard
    hostname: tensorboard
    command: tensorboard --logdir /logs --host 0.0.0.0 --port 6006
    volumes:
      - tensorboard_logs:/logs:ro  # Read-only access
    restart: unless-stopped
    networks:
      - frontend
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.tensorboard.rule=Host(`${TENSORBOARD_DOMAIN}`)"
      - "traefik.http.routers.tensorboard.entrypoints=websecure"
      - "traefik.http.routers.tensorboard.tls.certresolver=letsencrypt"
      - "traefik.http.services.tensorboard.loadbalancer.server.port=6006"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6006/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s

  # ===============================================
  # Projector Worker - TensorBoard Viz Generator
  # ===============================================
  projector:
    image: gsantopaolo/echomind-projector:${PROJECTOR_VERSION:-latest}
    build:
      context: ../../src
      dockerfile: projector/Dockerfile
    container_name: echomind-projector
    hostname: projector
    env_file:
      - ${CONFIG_PATH}/projector/projector.env
    environment:
      - PROJECTOR_LOG_LEVEL=${PROJECTOR_LOG_LEVEL:-INFO}
      - PROJECTOR_NATS_URL=nats://nats:4222
      - PROJECTOR_STREAM_NAME=projector-stream
      - PROJECTOR_CONSUMER_NAME=projector-worker
      - PROJECTOR_SUBJECT=projector.generate
      - PROJECTOR_QDRANT_URL=http://qdrant:6333
      - PROJECTOR_QDRANT_API_KEY=${QDRANT_API_KEY:-}
      - PROJECTOR_LOG_DIR=/logs
      - TENSORBOARD_DOMAIN=${TENSORBOARD_DOMAIN}
    volumes:
      - tensorboard_logs:/logs  # Write access
    depends_on:
      postgres:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      nats:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    restart: unless-stopped
    networks:
      - backend

  # ===============================================
  # EchoMind WebUI - Static SvelteKit Frontend (Nginx)
  # ===============================================
  # Lightweight nginx container serving static SvelteKit SPA (~5MB).
  # All API calls are routed to EchoMind API via Traefik path-based routing.
  # No Python backend needed - just static files.
  webui:
    image: gsantopaolo/echomind-webui:${WEBUI_VERSION:-0.1.0-beta.1}
    build:
      context: ../../../echomind-webui
      dockerfile: Dockerfile.nginx
      args:
        - BUILD_HASH=${BUILD_HASH:-dev}
    container_name: echomind-webui
    hostname: webui
    # No environment variables needed - static files only
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:80/health"]
      interval: 30s
      timeout: 5s
      start_period: 10s
      retries: 3
    restart: unless-stopped
    networks:
      - frontend
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.webui.rule=Host(`${DOMAIN}`)"
      - "traefik.http.routers.webui.entrypoints=websecure"
      - "traefik.http.routers.webui.tls.certresolver=letsencrypt"
      - "traefik.http.services.webui.loadbalancer.server.port=80"
      # Low priority - API routes (priority=100) take precedence
      - "traefik.http.routers.webui.priority=1"

  # ===============================================
  # [DEPRECATED] EchoMind Web - React Frontend
  # ===============================================
  # NOTE: DO NOT DELETE - Keep for quick rollback if needed.
  # This is the original React-based frontend. To revert:
  #   1. Comment out the 'webui' service above
  #   2. Uncomment this 'web' service
  #   3. Update Traefik labels if needed
  # ===============================================
  # web:
  #   image: gsantopaolo/echomind-web:${WEB_VERSION:-0.1.0-beta.1}
  #   build:
  #     context: ../../src/web
  #     dockerfile: Dockerfile
  #     args:
  #       - VITE_API_BASE_URL=${API_URL}/api/v1
  #       - VITE_WS_URL=${WS_URL}
  #       - VITE_OIDC_AUTHORITY=${WEB_OIDC_AUTHORITY}
  #       - VITE_OIDC_CLIENT_ID=${WEB_OIDC_CLIENT_ID}
  #       - VITE_OIDC_REDIRECT_URI=${WEB_OIDC_REDIRECT_URI}
  #       - VITE_OIDC_POST_LOGOUT_REDIRECT_URI=${WEB_OIDC_POST_LOGOUT_REDIRECT_URI}
  #       - VITE_OIDC_SCOPE=${WEB_OIDC_SCOPE}
  #   container_name: echomind-web
  #   hostname: web
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost/health"]
  #     interval: 10s
  #     timeout: 3s
  #     start_period: 5s
  #     retries: 3
  #   depends_on:
  #     api:
  #       condition: service_started
  #     authentik-server:
  #       condition: service_started
  #   restart: unless-stopped
  #   networks:
  #     - frontend
  #   labels:
  #     - "traefik.enable=true"
  #     - "traefik.http.routers.web.rule=Host(`${DOMAIN}`)"
  #     - "traefik.http.routers.web.entrypoints=websecure"
  #     - "traefik.http.routers.web.tls.certresolver=letsencrypt"
  #     - "traefik.http.services.web.loadbalancer.server.port=80"
